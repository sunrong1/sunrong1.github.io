---
icon: pen-to-square
date: 2025-09-10
category:
  - 算法
tag:
  - 算法基础
  - 方法论
star: true
---

# 算法 Primary

9月14日到2月16日（除夕）5个月：金丹期，6个月元婴。
目标凡人修仙之元婴级大佬

1. 练气期（基础巩固）：9月14日 - 10月30日（1个月）
  ○ 目标：完成100道基础题，基础的数据结构和算法（重点：数组、字符串、链表、栈、队列、排序、搜索、递归，树初级,图初级）。
  ○ 题数里程碑：每10题为一层，共10层（练气1层10题、2层20题、...、10层100题）。
  ○ 时间分配：每周约10题，每天2题左右（利用晚上1小时+早上地铁1h）。
  ○ 多巴胺激励：每完成10题，奖励自己一个小愿望（如给老家做规划，和儿子做游戏、咖啡、零食）；完成练气期，奖励一个周末家庭活动（如公园游玩）。
  ○ 建议：使用LeetCode或牛客网，选择Easy和Medium题，注重理解基础概念。

题目：
https://leetcode.cn/studyplan/top-interview-150/ 
极客时间-alg：
https://time.geekbang.org/column/article/68334
开发地址：
https://github.com/codespaces/vigilant-zebra-w49wx5j6vrc5v4x

## 整体算法学习计划
总目标：完成200道算法题，并融会贯通，应对2026年3月前达到元婴级别。
阶段详情：

1. 筑基期（进阶学习，第二阶段）：11月15日 - 12月31日（1.5个月）
  ○ 目标：完成50道中等题（总题数150题），重点：树-中级、图中级、动态规划、贪心算法。
  ○ 题数里程碑：筑基初期120题、筑基中期140题、筑基圆满150题。
  ○ 时间分配：每周约7题，每天1题左右（中等题耗时较多，周末可集中）。
  ○ 多巴胺激励：每完成15题，奖励自己一次小享受（如咖啡、零食）；完成筑基期，奖励一个晚上外出晚餐。
  ○ 建议：参加LeetCode周赛检验学习效果，复习错题。

1. 金丹期（高级主题）：1月1日 - 2月15日（1.5个月）
  ○ 目标：完成50道困难题（总题数200题），重点：高级动态规划、图算法、系统设计基础、并发问题。
  ○ 题数里程碑：金丹初期170题、金丹中期185题、金丹圆满200题。
  ○ 时间分配：每周约5.5题，每天1题（困难题可能每天只能完成1题，周末复习）。
  ○ 多巴胺激励：每完成20题，奖励自己一个电影夜；完成金丹期，奖励一个技术书籍或在线课程。
  ○ 建议：注重解题思路和优化，学习面试技巧（如时间管理）。
2. 元婴期（融会贯通）：2月16日 - 3月1日（2周）
  ○ 目标：不增加新题，复习所有200题，进行模拟面试（使用Mock平台如Pramp）。
  ○ 时间分配：每周复习50题，完成2-3次模拟面试。
  ○ 多巴胺激励：每完成5次模拟面试，奖励自己一个休息日；完成元婴期，奖励一个家庭周末旅行。
  ○ 建议：重点关注弱点和面试模拟，调整心态。
3. 元婴期圆满（目标公司）：3月2日到5月1日
  ○ 目标：保持手感，每天1-2题，模拟公司interview，健康调整。
  ○ 多巴胺激励：每个Interview成功，奖励小礼物；面试后无论结果，奖励一次大餐。
  ○ 建议：确保充足睡眠，避免 burnout。


时间管理建议：
● 每日流程：晚上9点到家后，休息30分钟，然后学习算法1小时（9:30-10:30）。通勤时间可听算法课程（如YouTube频道）或思考问题，但避免过度疲劳。
● 周末学习：周六或周日安排2-3小时集中学习，但预留半天家庭时间。
● 工具推荐：使用LeetCode刷题，搭配Notion或Excel跟踪进度；加入学习群组保持动力。
● 家庭平衡：学习时可与孩子分享简单算法概念（如排序游戏），让他参与您的学习旅程，但确保有专属家庭时间。
灵活性调整：
● 如果某周进度落后，不要焦虑，调整下周目标。健康家庭第一。
● 学习AI方面：算法是AI的基础，但当前集中算法面试，AI学习可暂放或每周花1小时了解概念。


| 阶段   | 月份   | 核心目标               | 重点专题                             | 关键练习题目（LeetCode）             |
|--------|--------|------------------------|--------------------------------------|--------------------------------------|
| 奠基   | 第1个月 | 建立算法思维基础       | 数组/字符串、哈希、链表、二叉树基础与递归 | #283, #1, #206, #104, #226, #101     |
| 攻坚   | 第2个月 | 攻克核心数据结构       | 二叉树进阶、回溯、动态规划(一)、图基础   | #105, #236, #124, #46, #78, #70, #53 |
| 深化   | 第3个月 | **mastering 动态规划** | 动态规划(二)(三)、贪心、系统设计算法     | #122, #300, #1143, #322, #55, #146, #215 |
| 融合   | 第4个月 | 融会贯通与面试模拟     | 高频企业真题、综合复习、面试技巧         | 专项刷“二叉树”和“DP”高频题，模拟面试 |

## 前20的算法题过程和心得

1. 第38周
9-15~9-17:
每天看3~4个题目，每天听一个数据和算法的极客时间一篇；但是做题的速度比较慢；一天不到1题；
构建好了Java17的环境；

9-18~9~20：
听到了栈、队列;

更加准确和深度的理解了引用赋值和值复制，解决了长久的链表赋值的困惑：

```java
        //创建新的链表，带头节点
        ListNode head = new ListNode(-1);
        ListNode ret = head;
        ListNode t1 = list1;//临时指针变量
        ListNode t2 = list2;//临时指针变量
        while (t1 != null && t2 != null){
            //值比较，先插入t2
            if (t1.val > t2.val) {
                ret.next = t2;//值变量赋值
                t2 = t2.next; //引用赋值
                ret = ret.next;
            }
            else {
                ret.next = t1;
                t1 = t1.next;
                ret = ret.next;
            }
        }

```

2. 39周
   9-22 ~9-29
   听了数据结构的极客时间，听了排序的极客时间；
   理解不需要刚开始写完美的代码，有自己的思路和模板，养成绘图的习惯，更重要。
   学习递归、排序：利用归并排序，去理解递归的思想，递归的写法，递归的优化，递归的复杂度分析。嗯，不错的知识关联方法学习；
   理解了排序的思想，快速排序、归并排序的思想，归并排序的写法，归并排序的复杂度分析；
   学习了非比较类的排序：桶排序、计数排序、基数排序；
   学习排序算法的设计；
3. 40-41 周国庆 期间，6天
   30号开车休息；
   早上 6:30~7:30 听极客时间和总结, 2个番茄; 7:40~8:30： 做算法题 2个番茄    
   晚上 10点 学习springboot；2个番茄
   7号：回上海,休息
   最低要求完成二叉树、堆、散列表 的学习；

   
   听了 数组、链表、栈、队列、排序、递归、二叉树、哈希、图、动态规划、贪心、回溯、分治、二分查找、字符串、位运算、
   二叉树、排序、递归、栈、队列、链表、数组、散列表、二分查找、字符串的总结
   每天抽实际做1~2题，电脑拿回家。
   早期练习
### 排序
冒泡排序、插入排序、选择排序；
平时我们使用插入排序的时候更多。

### 数组

### 链表

1. 问题：链表复制，java在内存中到底做了什么？
  ListNode slow = head;
  ​slow创建了哪些储存空间？​​

换句话说：当你写了这行代码时，​Java 在内存中到底分配了什么？slow是否占用了新的内存空间？它创建了新的链表节点吗？

问题：
✅ （1）在栈内存中：
​声明了一个新的变量 slow，类型为 ListNode，这个变量会保存一个引用（即内存地址）。
这个变量 slow是方法内的一个 ​局部变量，它存在于 ​栈帧（stack frame）​​ 中。
✅ （2）在赋值时：
你将 head的值（也就是它保存的 ​引用 / 地址）​复制给了 slow。
也就是说：​slow和 head现在指向的是堆内存中的同一个 ListNode对象（比如头节点）​。

🔁 ​总结：​​
你​没有创建任何新的 ListNode对象​（也就是没有创建新的节点）。
你​只是创建了一个新的引用变量 slow（在栈上）​，它指向了和 head相同的对象（在堆上）。

### 二叉树


### 图


